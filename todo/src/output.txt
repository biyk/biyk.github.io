--- FILE: E:\work\biyk.github.io\todo\src\agents\taskAgent.js ---
import {listEvents} from "@/utils/calendar.js";

let intervalId = null;

export function startTaskAgent(store) {
    if (intervalId) return; // –∞–≥–µ–Ω—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç

    intervalId = setInterval(async () => {
        store.dispatch("todos/initTodos");
        const todos = store.getters['todos/getTodos'];
        await listEvents(store);
        const now = new Date();

        todos.forEach(todo => {
            // üß† –ü—Ä–∏–º–µ—Ä —É—Å–ª–æ–≤–∏—è:TODO –µ—Å–ª–∏ –∑–∞–¥–∞—á–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–∞ ‚Äî –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –ø–µ—Ä–∏–æ–¥
            if (todo.task_finish_date) {
                //–≤ —Ü–∏–∫–ª–µ –ø–æ–∫–∞ –¥–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –Ω–µ –±—É–¥–µ—Ç –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–π –¥–∞—Ç—ã
                if (todo.task_finish_date < now.getTime()) {
                    //console.log("–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—É—é –∑–∞–¥–∞—á—É:", todo.task_title);
                    //–Ω–∞–∫–∏–¥—ã–≤–∞–µ–º —à—Ç—Ä–∞—Ñ
                    //–º–µ–Ω—è–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
                    //–ø–µ—Ä–µ–Ω–æ—Å–∏–º –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –ø–µ—Ä–∏–æ–¥
                }
            }

            // üîÅ –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –¥—Ä—É–≥–∏–µ —É—Å–ª–æ–≤–∏—è/–¥–µ–π—Å—Ç–≤–∏—è
        });
    }, 60 * 1000); // —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É
}

export function stopTaskAgent() {
    if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
        console.log("[–ê–≥–µ–Ω—Ç] –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.");
    }
}


--- FILE: E:\work\biyk.github.io\todo\src\App.vue ---
<template>
    <div class="container">
        <h1>{{hero.hero_name}} {{hero.hero_money}} ({{ currentTime }})</h1>
        <el-tabs v-model="activeTab">
            <el-tab-pane label="–ö–∞–ª–µ–Ω–¥–∞—Ä—å" name="calendar">
                <TodoList filter="calendar"  />
            </el-tab-pane>
            <el-tab-pane label="–ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏" name="today">
                <TodoList filter="today"  />
            </el-tab-pane>
            <el-tab-pane label="–°–ø–∏—Å–æ–∫" name="list">
                <TodoList filter="all" />
            </el-tab-pane>
            <el-tab-pane label="–î–æ–±–∞–≤–∏—Ç—å" name="new">
                <TodoNew />
            </el-tab-pane>
            <el-tab-pane label="–ú–∞–≥–∞–∑–∏–Ω" name="shop">
                <div>–¢—É—Ç –±—É–¥—É—Ç –ø–æ–∫—É–ø–∫–∏</div>
            </el-tab-pane>
            <el-tab-pane label="–ü–µ—Ä—Å–æ–Ω–∞–∂" name="player">
                <div>–¢—É—Ç –±—É–¥—É—Ç –¥–∞–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∞</div>
            </el-tab-pane>
            <el-tab-pane label="–ù–∞—Å—Ç—Ä–æ–π–∫–∏" name="settings">
                <Settings/>
            </el-tab-pane>
        </el-tabs>
        <img src="@/assets/logo.png" class="vue-logo" alt="Vue.js Logo" />
    </div>
</template>

<script>
import { computed, onMounted, onBeforeUnmount } from 'vue'
import TodoNew from "@/components/TodoNew.vue"
import TodoList from "@/components/TodoList.vue"
import Settings from "@/components/Settings.vue"
import { useStore } from 'vuex'
import 'element-plus/dist/index.css'
import './assets/styles/App.css'
import { startTaskAgent, stopTaskAgent } from "@/agents/taskAgent.js"  // ‚Üê üî•

export default {
    data() {
        return {
            currentTime: new Date().toLocaleString(),
        };
    },
    components: {
        Settings,
        TodoNew,
        TodoList
    },
    computed: {
        hero() {
            return this.$store.getters["hero/getHero"];
        },
    },
    setup() {
        const activeTab = computed({
            get() {
                return window.location.hash.replace('#/', '') || 'calendar';
            },
            set(val) {
                window.location.hash = val;
            }
        });

        const store = useStore();

        onMounted(() => {
            startTaskAgent(store);
        });

        onBeforeUnmount(() => {
            stopTaskAgent();
        });

        return { activeTab };
    },
    mounted() {
        this.$store.dispatch("hero/initHero");
        this.timer = setInterval(() => {
            this.currentTime = new Date().toLocaleString();
        }, 1000);
    }

}
</script>



--- FILE: E:\work\biyk.github.io\todo\src\components\Settings.vue ---
<template>
    <div class="settings">
        <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>

        <!-- –ö–Ω–æ–ø–∫–∞ "–î–æ–±–∞–≤–∏—Ç—å" -->
        <button @click="showForm = !showForm">
            {{ showForm ? '–û—Ç–º–µ–Ω–∞' : '–î–æ–±–∞–≤–∏—Ç—å' }}
        </button>

        <!-- –§–æ—Ä–º–∞ –¥–ª—è –≤–≤–æ–¥–∞ –Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è -->
        <div v-if="showForm" class="form">
            <input
                v-model="code"
                placeholder="–ö–æ–¥ (code)"
                type="text"
            />
            <input
                v-model="value"
                placeholder="–ó–Ω–∞—á–µ–Ω–∏–µ (value)"
                type="text"
            />
            <button @click="saveSetting">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        </div>

        <!-- –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –ø–∞—Ä –∫–æ–¥/–∑–Ω–∞—á–µ–Ω–∏–µ -->
        <div v-if="settings.length > 0">
            <h3>–°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:</h3>
            <ul>
                <li v-for="(setting, index) in settings" :key="index">
                    <span>{{ setting.code }}: {{ setting.value }}</span>
                    <button @click="deleteSetting(index)">–£–¥–∞–ª–∏—Ç—å</button>
                </li>
            </ul>
        </div>
    </div>
</template>

<script>
import { generateUUIDv4 } from '@/utils/uuid';

export default {
    name: 'Settings',
    data() {
        return {
            showForm: false,
            code: '',
            value: '',
        }
    },
    computed: {
        // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
        settings() {
            return this.$store.state.settings.settings  // assuming you're using the 'settings' module
        }
    },
    methods: {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—É—é –ø–∞—Ä—É –∫–æ–¥/–∑–Ω–∞—á–µ–Ω–∏–µ
        saveSetting() {
            const setting = {
                code: this.code.trim(),
                uid: generateUUIDv4(),
                value: this.value.trim(),
            }

            if (!setting.code || !setting.value) {
                alert("–û–±–∞ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã")
                return
            }

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ Vuex
            this.$store.dispatch("settings/saveSettings", setting)

            // –û—á–∏—Å—Ç–∏—Ç—å —Ñ–æ—Ä–º—É –∏ —Å–∫—Ä—ã—Ç—å –µ—ë
            this.code = ''
            this.value = ''
            this.showForm = false
        },
        // –£–¥–∞–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –ø–æ –∏–Ω–¥–µ–∫—Å—É
        deleteSetting(index) {
            this.$store.dispatch("settings/deleteSetting", index)
        },
    },
}
</script>

<style scoped>
.settings {
    margin-top: 1rem;
}
.form {
    margin-top: 1rem;
}
input {
    display: inline-block;
    margin-right: 0.5rem;
    padding: 0.5rem;
    width: 150px;
}
button {
    padding: 0.5rem 1rem;
    margin-left: 1rem;
}
ul {
    list-style-type: none;
    padding: 0;
}
li {
    display: flex;
    align-items: center;
    margin-bottom: 0.5rem;
}
li button {
    margin-left: 10px;
    padding: 0.2rem 0.5rem;
}
</style>


--- FILE: E:\work\biyk.github.io\todo\src\components\TodoList.vue ---
<template>
    <button v-if="filter==='calendar'" @click="setTaskToCalendar">–ó–∞–ø–æ–ª–Ω–∏—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å</button>
    <button  v-if="filter==='calendar'" @click="setTaskCompleted">–û—Ç–º–µ—Ç–∏—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ</button>
    <ul class="tasks">
        <li>{{getSortedTodos().length}} ({{getTotalTime()}} —á.)</li>
        <li
            v-for="todo in getSortedTodos()"
            :key="todo.id"
            :class="['task', todo.task_color, { completed: todo.completed }]"
        >
                    <span
                        :title="taskDate(todo.task_date)"
                        @click="togglePopover(todo.task_uuid)"
                        style="cursor: pointer;"
                    >
                        ({{ todo.task_sort }} / {{taskSort(todo)}}) {{ todo.task_title }} ({{taskDate(todo.task_date)}})
                    </span>

            <div v-if="visiblePopover === todo.task_uuid" class="editable-description">
                <textarea
                    v-model="todo.task_description"
                    rows="3"
                    style="width: 100%; margin-top: 8px;"
                ></textarea>
                <button @click="closeEditor(todo)" style="margin-top: 4px;">‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>


            <div v-if="!visiblePopover !== todo.task_uuid" class="buttons">
                <span class="done" @click.stop="toggleTodo(todo.task_uuid)">‚úÖ</span>
                <span class="delete" @click.stop="deleteTodo(todo.task_uuid)">‚ìß</span>
            </div>
        </li>

    </ul>
</template>

<script>
import '../assets/styles/components/TodoList.css';
import {makeTaskDone, setTaskCompleted, setTaskToCalendar, taskDate, taskSort} from "@/utils/tasks.js";
import {addEvent, listEvents, updateEvent} from "@/utils/calendar.js";
import throttle from 'lodash/throttle';
export default {
    data() {
        return {
            visiblePopover: null,
            total: 0
        };
    },
    computed: {
        todos() {
            return this.$store.getters["todos/getTodos"];
        },
        events() {
            return this.$store.getters["events/getEvents"];
        },
    },
    props: {
        filter: {
            type: String,
            default: 'all'
        }
    },
    methods: {
        setTaskCompleted,
        setTaskToCalendar,
        taskDate,
        taskSort,
        getFilteredTodos() {
            const now = new Date();
            const today = new Date().getTime();
            const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 23, 59, 0, 0).getTime();
            return this.todos.filter(todo => {
                if (todo.task_title.includes('task_title')) return false;
                const start = parseInt(todo.task_date);
                switch (this.filter) {
                    case 'today':
                        return start < today;
                    case 'calendar':
                        const calendarEvents = this.events;
                        const hasMatchingEvent = calendarEvents?.some(
                            event => event.description?.includes(todo.task_uuid)
                        );
                        return start < today && hasMatchingEvent;
                    case 'tomorrow':
                        return start > today && start < tomorrow;
                    default:
                        return true;
                }
            });
        },

        closeEditor(todo) {
            this.visiblePopover = null;
            this.$store.dispatch("todos/updateTodo", { ...todo }); // –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        },

        async toggleTodo(task_uuid) {
            const task = this.todos.filter(todo => todo.task_uuid === task_uuid);
            const endDate = new Date();
            const startDate = new Date(endDate.getTime() - task[0].task_time * 60 * 1000);
            const event = {
                summary: task[0].task_title,
                description: task[0].task_uuid,
                colorId: 7,
                start: {
                    dateTime: startDate.toISOString(),
                    timeZone: 'Europe/Samara',
                },
                end: {
                    dateTime: endDate.toISOString(),
                    timeZone: 'Europe/Samara',
                },
            };
            let list = await listEvents(this.$store);

            let exist = list.filter(event => event.description?.includes(task_uuid));
            if(exist.length){
                event.summary = exist[0].summary;
                event.id = exist[0].id
                await updateEvent(event)
            } else {
                await addEvent(event);
                //—Ç.–∫. –∑–∞–¥–∞—á–∞ –±—ã–ª–∞ –Ω–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
                task[0].break_multiplier = parseInt(task[0].break_multiplier) + 1;
            }
            makeTaskDone(task, this.$store);
        },
        deleteTodo: throttle(function(task_uuid) {
            const task = this.todos.filter(todo => todo.task_uuid === task_uuid);
            makeTaskDone(task, this.$store, { deleted: 1 });
        }, 1000),
        getSortedTodos(){
            switch (this.filter) {
                case 'calendar':
                    const calendarOrder = this.events
                        .map(event => event.description)
                        .filter(uuid => uuid); // —É–¥–∞–ª–∏–º undefined/null

                    // –°–æ–∑–¥–∞—ë–º –∫–∞—Ä—Ç—É —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è UUID ‚Üí –ø–æ—Ä—è–¥–æ–∫
                    const uuidOrderMap = new Map();
                    calendarOrder.forEach((uuid, index) => {
                        uuidOrderMap.set(uuid, index);
                    });

                    // —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∏—Ö –ø–æ—Ä—è–¥–∫—É –≤ events
                    return this.getFilteredTodos()
                        .sort((a, b) => uuidOrderMap.get(a.task_uuid) - uuidOrderMap.get(b.task_uuid));
                case 'today':
                case 'tomorrow':
                default:
                    return this.getFilteredTodos().sort((a, b) => {
                        return taskSort(a) - taskSort(b)
                    });
            }
        },
        getTotalTime() {
            let summ = 0;
            this.getSortedTodos().forEach((task) => {
                summ += Number(task.task_time) || 0;
            });
            return (summ / 60).toFixed(2);
        },
        togglePopover(uuid) {
            this.visiblePopover = this.visiblePopover === uuid ? null : uuid;
        },
    },
    mounted() {
        this.$store.dispatch("todos/initTodos");
        listEvents(this.$store);
    }
};
</script>




--- FILE: E:\work\biyk.github.io\todo\src\components\TodoNew.vue ---
<template>
    <form>
        <input
            class="todo-input"
            type="text"
            placeholder="Enter a new task"
            v-model="task_title"
        />
        <button @click="addTodo" type="button">+</button>
    </form>
</template>

<script>
import '../assets/styles/components/TodoNew.css';
import { generateUUIDv4 } from '@/utils/uuid';
export default {
    data() {
        return {
            task_title: "",
            task_uuid: generateUUIDv4()
        };
    },
    methods: {
        addTodo: function() {
            this.$store.dispatch("todos/addTodo", {
                task_uuid: this.newId,
                task_title: this.task_title
            });
            this.task_uuid = generateUUIDv4();
            this.task_title = "";
        }
    }

};
</script>



--- FILE: E:\work\biyk.github.io\todo\src\index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TODO</title>
    <script>window.version = '0.2.72'</script>
    <script  type="module" src="./../../dnd/static/js/version.js"></script>
</head>
<body>
<div id="app"></div>
<div style="
    display: flex;
    position: absolute;
">
    <button id="authorize_button" >Authorize</button>
    <button id="signout_button">Sign Out</button>
</div>

<script type="module" src="main.js"></script>
</body>
</html>


--- FILE: E:\work\biyk.github.io\todo\src\main.js ---
import { createApp } from 'vue'
import App from './App.vue'
import ElementPlus from 'element-plus'
import router from './router'
import store from './store/store.js'

createApp(App)
    .use(router)
    .use(store)
    .use(ElementPlus)
    .mount('#app')


--- FILE: E:\work\biyk.github.io\todo\src\router.js ---
import { createRouter, createWebHashHistory } from 'vue-router';
import App from '@/App.vue';

const routes = [
    {
        path: '/',
        name: 'Home',
        component: App,
    },
];

const router = createRouter({
    history: createWebHashHistory(), // ‚Üê –∑–∞–º–µ–Ω–∏–ª–∏ –∑–¥–µ—Å—å
    routes,
});

export default router;


--- FILE: E:\work\biyk.github.io\todo\src\store\modules\events.js ---
import {GoogleSheetDB, ORM, Table} from "../../../../dnd/static/js/db/google.js";

const LOCAL_STORAGE_KEY = "events-list";

const saveEvents = (hero) => {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(hero));
};

const loadEvents = () => {
    const data =  localStorage.getItem(LOCAL_STORAGE_KEY);
    return data ? JSON.parse(data) : [];
};

export const state = {
    events: loadEvents()
};

export const getters = {
    getEvents: state => state.events,
};

export const mutations = {
    SET_EVENTS(state, events) {
        state.events = events;
        saveEvents(state.events);
    },
};

async function getGoogleSheetTable(rootGetters) {
    const settings = rootGetters["settings/allSettings"];
    const spreadsheetSetting = settings.find(s => s.code === "spreadsheetId");
    if (!spreadsheetSetting) {
        console.warn("spreadsheetId not found in settings");
        return null;
    }

    const api = window.GoogleSheetDB || new GoogleSheetDB();
    await api.waitGoogle();

    return new Table({
        spreadsheetId: spreadsheetSetting.value,
        list: "real_life_hero"
    });
}

export const actions = {
    async initHero({ commit, rootGetters }) {
        const table = await getGoogleSheetTable(rootGetters);
        if (!table) {
            commit("SET_HERO", loadHero());
            return;
        }

        const list = await table.getAll({caching:5});
        const orm = new ORM(table.columns[table.list]);
        let hero = {};
        list.map(e => {
            let formated = orm.getFormated(e)
            hero[formated.code] = formated.value;
        });
        commit("SET_HERO", hero);
    },

    async setEvents({ commit, rootGetters }, events) {
        commit("SET_EVENTS", events);
    }
};


--- FILE: E:\work\biyk.github.io\todo\src\store\modules\hero.js ---
import {GoogleSheetDB, ORM, Table} from "../../../../dnd/static/js/db/google.js";

const LOCAL_STORAGE_KEY = "hero-list";

const saveHero = (hero) => {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(hero));
};

const loadHero = () => {
    const data =  localStorage.getItem(LOCAL_STORAGE_KEY);
    return data ? JSON.parse(data) : [];
};

export const state = {
    hero: loadHero()
};

export const getters = {
    getHero: state => state.hero,
};

export const mutations = {
    UPDATE_HERO(state, hero) {
        state.hero = hero;
        saveHero(state.hero);
    },

    SET_HERO(state, hero) {
        state.hero = hero;
        saveHero(state.hero);
    },
};

async function getGoogleSheetTable(rootGetters) {
    const settings = rootGetters["settings/allSettings"];
    const spreadsheetSetting = settings.find(s => s.code === "spreadsheetId");
    if (!spreadsheetSetting) {
        console.warn("spreadsheetId not found in settings");
        return null;
    }

    const api = window.GoogleSheetDB || new GoogleSheetDB();
    await api.waitGoogle();

    return new Table({
        spreadsheetId: spreadsheetSetting.value,
        list: "real_life_hero"
    });
}

export const actions = {
    async initHero({ commit, rootGetters }) {
        const table = await getGoogleSheetTable(rootGetters);
        if (!table) {
            commit("SET_HERO", loadHero());
            return;
        }

        const list = await table.getAll({caching:5});
        const orm = new ORM(table.columns[table.list]);
        let hero = {};
        list.map(e => {
            let formated = orm.getFormated(e)
            hero[formated.code] = formated.value;
        });
        commit("SET_HERO", hero);
    },

    async updateHero({ commit, rootGetters }, hero) {
        commit("UPDATE_HERO", hero);

        const table = await getGoogleSheetTable(rootGetters);
        if (!table) return console.log('–Ω–µ—Ç —Ç–∞–±–ª–∏—Ü—ã –≥–µ—Ä–æ—è');
        await table.updateRowByCode('hero_money', {value:hero.hero_money});
    }

};


--- FILE: E:\work\biyk.github.io\todo\src\store\modules\settings.js ---
const LOCAL_STORAGE_KEY = "todo-settings";

async function saveToStorage(todos) {
    await localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(todos));
}

function loadFromStorage() {
    const data =  localStorage.getItem(LOCAL_STORAGE_KEY);
    return data ? JSON.parse(data) : [];
}


export const state = {
    settings: loadFromStorage(),  // –ú–∞—Å—Å–∏–≤ –Ω–∞—Å—Ç—Ä–æ–µ–∫
}

export const getters = {
    allSettings: (state) => state.settings,  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
}

export const mutations = {
    async SET_SETTINGS(state, setting) {
        state.settings.push(setting)  // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É –≤ –º–∞—Å—Å–∏–≤
        await saveToStorage(state.settings)
    },
    async DELETE_SETTING(state, index) {
        state.settings.splice(index, 1)  // –£–¥–∞–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –ø–æ –∏–Ω–¥–µ–∫—Å—É
        await saveToStorage(state.settings)
    },
}

export const actions = {
    saveSettings({ commit }, setting) {
        commit('SET_SETTINGS', setting)  // –í—ã–∑—ã–≤–∞–µ–º –º—É—Ç–∞—Ü–∏—é –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    },
    deleteSetting({ commit }, index) {
        commit('DELETE_SETTING', index)  // –í—ã–∑—ã–≤–∞–µ–º –º—É—Ç–∞—Ü–∏—é –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    },
}


--- FILE: E:\work\biyk.github.io\todo\src\store\modules\todos.js ---
import {GoogleSheetDB, ORM, Table} from "../../../../dnd/static/js/db/google.js";

const LOCAL_STORAGE_KEY = "todo-list";

const saveTodos = (todos) => {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(todos));
};

const loadTodos = () => {
    const data =  localStorage.getItem(LOCAL_STORAGE_KEY);
    return data ? JSON.parse(data) : [];
};

export const state = {
    todos: loadTodos()
};

export const getters = {
    getTodos: state => state.todos,
};

export const mutations = {
    UPDATE_TODO(state, updatedTask) {
        const index = state.todos.findIndex(t => t.task_uuid === updatedTask.task_uuid);
        if (index !== -1) {
            state.todos.splice(index, 1, updatedTask);
            saveTodos(state.todos);
        }
    },

    SET_TODOS(state, todos) {
        state.todos = todos;
        saveTodos(state.todos);
    },
    ADD_TODO(state, payload) {
        const newTask = {
            id: payload.newId,
            task: payload.task,
            completed: false,
        };
        state.todos.unshift(newTask);
        saveTodos(state.todos);
    },
    TOGGLE_TODO(state, payload) {
        const item = state.todos.find(todo => todo.id === payload);
        if (item) {
            item.completed = !item.completed;
            saveTodos(state.todos);
        } else {
            console.error("Todo not found with id:", payload);
        }
    },
    DELETE_TODO(state, payload) {
        const index = state.todos.findIndex(todo => todo.id === payload);
        if (index !== -1) {
            state.todos.splice(index, 1);
            saveTodos(state.todos);
        } else {
            console.error("Todo not found with id:", payload);
        }
    }
};

async function getGoogleSheetTable(rootGetters) {
    const settings = rootGetters["settings/allSettings"];
    const spreadsheetSetting = settings.find(s => s.code === "spreadsheetId");
    if (!spreadsheetSetting) {
        console.warn("spreadsheetId not found in settings");
        return null;
    }

    const api = window.GoogleSheetDB || new GoogleSheetDB();
    await api.waitGoogle();

    return new Table({
        spreadsheetId: spreadsheetSetting.value,
        list: "real_life_tasks"
    });
}

export const actions = {
    async initTodos({ commit, rootGetters }) {
        const table = await getGoogleSheetTable(rootGetters);
        if (!table) {
            commit("SET_TODOS", loadTodos());
            return;
        }

        const list = await table.getAll({caching:5});
        const orm = new ORM(table.columns["real_life_tasks"]);
        const todos = list.map(e => orm.getFormated(e));
        console.log('–ó–∞–≥—Ä—É–∑–∏–ª–∏ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω–µ –ø–æ –∑–∞–¥–∞—á–∞–º')
        commit("SET_TODOS", todos);
    },

    addTodo({ commit }, payload) {
        commit("ADD_TODO", payload);
    },
    toggleTodo({ commit }, payload) {
        commit("TOGGLE_TODO", payload);
    },
    deleteTodo({ commit }, payload) {
        commit("DELETE_TODO", payload);
    },
    async updateTodo({ commit, rootGetters }, updatedTask) {
        commit("UPDATE_TODO", updatedTask);

        const table = await getGoogleSheetTable(rootGetters);
        if (!table) return;

        await table.updateRowByCode(updatedTask.task_title, updatedTask);
    }

};


--- FILE: E:\work\biyk.github.io\todo\src\store\store.js ---
import { createStore } from 'vuex'
import * as todos from '@/store/modules/todos.js'  // —Ç–≤–æ–π –º–æ–¥—É–ª—å –¥–ª—è –∑–∞–¥–∞—á
import * as hero from '@/store/modules/hero.js'  // –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
import * as events from '@/store/modules/events.js'  // –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
import * as settings from '@/store/modules/settings.js'  // –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫

export default createStore({
    modules: {
        todos: { ...todos, namespaced: true },
        hero: { ...hero, namespaced: true },
        events: { ...events, namespaced: true },
        settings: { ...settings, namespaced: true }
    }
})


--- FILE: E:\work\biyk.github.io\todo\src\utils\cache.js ---
export class Cache {
    constructor(id) {
        this.id = id;
        this.ttl = sessionStorage.getItem(this.id+'_ttl');
        if (this.ttl < (new Date()).getTime()){
            this.value = null
        } else {
            try {
                this.value = JSON.parse(sessionStorage.getItem(this.id))
            } finally {
                this.value = null
            }
        }
    }

    get(){
        if (this.checkTTL()) return this.value
        return null
    }
    setTTL(time=60){
        this.ttl = (new Date()).getTime() + time*1000;
        sessionStorage.setItem(this.id+'_ttl', this.ttl);
    }
    set(value){
        this.setTTL();
        sessionStorage.setItem(this.id, JSON.stringify(value))
        this.value = value;
    }

    checkTTL(){
        return this.ttl < (new Date()).getTime()
    }
}

--- FILE: E:\work\biyk.github.io\todo\src\utils\calendar.js ---
import {GoogleSheetDB} from "../../../dnd/static/js/db/google.js";

export async function listEvents(store=false) {
    const api = window.GoogleSheetDB || new GoogleSheetDB();
    await api.waitGoogle();
    const today = new Date();
    const start = new Date(today.setHours(0, 0, 0, 0)).toISOString();
    const end = new Date(today.setHours(23, 59, 59, 999)).toISOString();

    let response = await gapi.client.calendar.events.list({
        calendarId: 'primary',
        timeMin: start,
        timeMax: end,
        showDeleted: false,
        singleEvents: true,
        orderBy: 'startTime'
    });

    const events = response.result.items;
    if (store){
        store.dispatch("events/setEvents", events);
    }
    return events;

}

export async function addEvent(event) {
    await gapi.client.calendar.events.insert({
        calendarId: 'primary',
        resource: event,
    });
    console.log('–°–æ–±—ã—Ç–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ:', event.summary);

}

export function makeEvent(task, slot,endDate) {
    return {
        summary: task.task_title,
        description: task.task_uuid,
        colorId:7,
        start: {
            dateTime: slot.start,
            timeZone: 'Europe/Samara',
        },
        end: {
            dateTime: endDate.toISOString(),
            timeZone: 'Europe/Samara',
        },
    }
}

export async function updateEvent(event) {
    await gapi.client.calendar.events.update({
        calendarId: 'primary',
        eventId: event.id,
        resource:event
    });
    console.log('–°–æ–±—ã—Ç–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ:', event.summary);

}

export function getFreeSlots(events, options={}) {
    if (!Array.isArray(events)) return [];
    let workEnd = '23:00', minSlotMinutes = 15;
    let now = new Date();

    let hours = String(now.getHours()).padStart(2, '0');
    let minutes = String(now.getMinutes()).padStart(2, '0');

    let workStart = `${hours}:${minutes}`;
    const day = new Date().toISOString().slice(0, 10); // 'YYYY-MM-DD'
    const toDateTime = (timeStr) => new Date(`${day}T${timeStr}:00`);

    const startOfDay = toDateTime(workStart);
    const endOfDay = toDateTime(workEnd);

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–æ–±—ã—Ç–∏—è –≤ –æ—Ç—Ä–µ–∑–∫–∏ –≤—Ä–µ–º–µ–Ω–∏
    const busySlots = events.map(e => ({
        start: new Date(e.start.dateTime || e.start.date),
        end: new Date(e.end.dateTime || e.end.date)
    }));

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –Ω–∞—á–∞–ª—É —Å–æ–±—ã—Ç–∏—è
    busySlots.sort((a, b) => a.start - b.start);

    const freeSlots = [];
    let cursor = new Date(startOfDay);

    for (const slot of busySlots) {
        if (slot.start > cursor) {
            const diff = (slot.start - cursor) / 60000; // –≤ –º–∏–Ω—É—Ç–∞—Ö
            if (diff >= minSlotMinutes) {
                freeSlots.push({
                    start: cursor.toISOString(),
                    end: slot.start.toISOString(),
                    duration: diff
                });
            }
        }
        // –ü—Ä–æ–¥–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤–ø–µ—Ä—ë–¥, –µ—Å–ª–∏ —Å–æ–±—ã—Ç–∏–µ –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å –ø–æ–∑–∂–µ —Ç–µ–∫—É—â–µ–≥–æ –∫—É—Ä—Å–æ—Ä–∞
        if (slot.end > cursor) {
            cursor = new Date(slot.end);
        }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–±—ã—Ç–∏—è –¥–æ –∫–æ–Ω—Ü–∞ –¥–Ω—è
    if (cursor < endOfDay) {
        const diff = (endOfDay - cursor) / 60000;
        if (diff >= minSlotMinutes) {
            freeSlots.push({
                start: cursor.toISOString(),
                end: endOfDay.toISOString(),
                duration: diff
            });
        }
    }

    return freeSlots;
}

--- FILE: E:\work\biyk.github.io\todo\src\utils\tasks.js ---
import {addEvent, getFreeSlots, listEvents, makeEvent} from "@/utils/calendar.js";

export function makeTaskDone(task, store, options={}){

    let {
        repeat_days_of_week,
        repeat_index,
        repeat_mode,
        task_date,
        task_finish_date,
        break_multiplier,
        number_of_executions
    } = task[0];
    let {deleted} = options;
    repeat_index = parseFloat(repeat_index);
    const now = new Date();

    console.log(repeat_mode);
    switch(repeat_mode) {
        case '0':
            task_date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 1, 0).getTime();
            task_finish_date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 23, 59, 0, 0).getTime();
            break;
        case '1':
            task_date = new Date(now.getFullYear(), now.getMonth() + 1, now.getDate() , 0, 0, 1, 0).getTime();
            task_finish_date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 23, 59, 0, 0).getTime();
            break;
        case '2':
            task_date = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate() , 0, 0, 1, 0).getTime();
            task_finish_date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 23, 59, 0, 0).getTime();
            break;
        case '6':
            task_date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + repeat_index, 0, 0, 1, 0).getTime();
            task_finish_date = new Date(now.getFullYear(), now.getMonth(), now.getDate() + repeat_index, 23, 59, 0, 0).getTime();
            break;
        case '5':
            task_date = new Date().getTime() + Math.round(repeat_index * 24*60*60*1000);
            task_finish_date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 0, 0).getTime();
            break;
        case '3':
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–∞–±–æ—á–µ–≥–æ –¥–Ω—è
            function getNextWorkingDayOffset(repeatDays, currentDay) {
                for (let offset = 1; offset <= 7; offset++) {
                    let dayIndex = (currentDay + offset) % 7;
                    if (repeatDays[dayIndex] === '1') {
                        return offset;
                    }
                }
                return null; // –Ω–µ—Ç —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π
            }

            const currentDay = now.getDay(); // 0 = –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ, ..., 6 = —Å—É–±–±–æ—Ç–∞
            const repeat_index3 = getNextWorkingDayOffset(repeat_days_of_week, currentDay);
            if (repeat_index3 === null) {
                throw new Error("–ù–µ—Ç —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏");
            }

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞—Ç—ã –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ –∑–∞–¥–∞—á–∏
            task_date = new Date(
                now.getFullYear(),
                now.getMonth(),
                now.getDate() + repeat_index3,
                0, 0, 1, 0
            ).getTime();

            task_finish_date = new Date(
                now.getFullYear(),
                now.getMonth(),
                now.getDate() + repeat_index3,
                23, 59, 0, 0
            ).getTime();
            break;
        default:
            //console.log(task[0])
            return;
    }
    number_of_executions++;
    const updatedTask = {
        ...task[0],
        task_date: task_date,
        break_multiplier: break_multiplier,
        task_finish_date: task_finish_date,
        number_of_executions:number_of_executions
    };
    store.dispatch("todos/updateTodo", updatedTask);

    if (deleted || repeat_mode==='5') return;
    let hero = { ...store.getters["hero/getHero"] }; // —Å–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –æ–±—ä–µ–∫—Ç–∞
    hero.hero_money = parseInt(hero.hero_money) + parseInt(task[0].money_reward);

    store.dispatch("hero/updateHero", hero);
}

export function taskSort(task){
    const now = new Date();
    const daysDiff = (timestamp) => {
        const diff = now - new Date(timestamp);
        return Math.floor(diff / (1000 * 60 * 60 * 24));
    };
    return task.task_sort - daysDiff(parseInt(task.task_date)) * task.break_multiplier
}

export async function  setTaskCompleted(){
    this.$store.dispatch("todos/initTodos");
    const now = new Date();
    //–ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–µ–ª –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
    let today_events = await listEvents();
    today_events.forEach((event)=>{
        let task_uuid = event.description;
        let todos = this.$store.getters["todos/getTodos"];
        const task = todos.filter(todo => todo.task_uuid === task_uuid);
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate() , now.getHours(), now.getMinutes(), 0, 0).getTime();

        if (task.length && (task[0].task_date < today) && (new Date(event.start.dateTime)).getTime() < today){
            makeTaskDone(task, this.$store);
        }
    });
}


export async function setTaskToCalendar() {
    //–ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
    this.$store.dispatch("todos/initTodos");

    //—Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–∞–¥–∞—á
    let all = this.$store.getters["todos/getTodos"].sort((a, b) => a.task_sort - b.task_sort);
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 0, 0).getTime();

    //—Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã —Å–¥–µ–ª–∞—Ç—å —Å–µ–≥–æ–¥–Ω—è
    let today_tasks = all.filter(todo => {
        if (todo.task_title === 'task_title') return false;
        const start = todo.task_date;
        return start < today;
    });

    //–ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–µ–ª –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏–∑ –∫–∞–ª–µ–Ω–¥–∞—Ä—è
    let today_events = await listEvents();
    today_tasks = today_tasks.sort((a, b) => {
        return taskSort(a) - taskSort(b)
    });
    console.log(today_tasks);

    //–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä—è —Å–æ–±—ã—Ç–∏—è
    let freeSlots = getFreeSlots(today_events);

    for (const task of today_tasks) {
        let duration = task.task_time;
        if (!duration || duration === '0') continue;
        //–ø–æ–∏—Å–∫ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Å–ª–æ—Ç–∞ –ø–æ–¥ –∑–∞–¥–∞—á—É
        let slotIndex = freeSlots.findIndex(slot => slot.duration >= duration);
        if (slotIndex === -1) continue; // –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —Å–ª–æ—Ç–∞

        let slot = freeSlots[slotIndex];
        let exist = today_events.filter((e) => {
            return e.description?.includes(task.task_uuid)
        });

        if (exist?.length) continue;

        let excluded = today_events.filter((e) => {
            return task.excludes?.includes(e.description)
        });
        if (excluded?.length) {
            console.log('–ù–µ —Å–µ–≥–æ–¥–Ω—è:', task);
            continue;
        }
        //–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å
        const endDate = new Date(new Date(slot.start).getTime() + duration * 60 * 1000);
        const event = makeEvent(task, slot, endDate);

        await addEvent(event);
        //–¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á—É –≤ —Å–ø–∏—Å–æ–∫ today_tasks

        // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–ª–∏ —É–¥–∞–ª–µ–Ω–∏–µ —Å–ª–æ—Ç–∞
        const updatedDuration = slot.duration - duration;
        if (updatedDuration < 15) {
            //—É–¥–∞–ª–∏—Ç—å —Å–ª–æ—Ç
            freeSlots.splice(slotIndex, 1);
        } else {
            //–æ–±–Ω–æ–≤–∏—Ç—å —Å–ª–æ—Ç
            freeSlots[slotIndex].start = endDate.toISOString();
            freeSlots[slotIndex].duration = updatedDuration;
        }
    }
    this.$store.dispatch("todos/initTodos");
}

export function taskDate(date){
    date = parseInt(date)
    return (new Date(date)).toLocaleString()
}

--- FILE: E:\work\biyk.github.io\todo\src\utils\uuid.js ---
// utils/uuid.js
export function generateUUIDv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(char) {
        const rand = Math.random() * 16 | 0;
        const value = char === 'x' ? rand : (rand & 0x3 | 0x8);
        return value.toString(16);
    });
}

--- FILE: E:\work\biyk.github.io\todo\src\vite.config.js ---
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [
        vue()
    ],
    base: "",
    resolve: {
        alias: {
            '@': resolve(__dirname, './') // ‚Üê –µ—Å–ª–∏ vite.config.js –≤–Ω—É—Ç—Ä–∏ src
            // –µ—Å–ª–∏ vite.config.js –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞, —Ç–æ './src'
        }
    },
    build: {
        minify: false,
        // –ü–∞–ø–∫–∞ –≤—ã—à–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ src => —ç—Ç–æ ../
        outDir: resolve(__dirname, '../'),
        emptyOutDir: false, // –æ—á–∏—â–∞–µ—Ç –ø–∞–ø–∫—É –ø–µ—Ä–µ–¥ —Å–±–æ—Ä–∫–æ–π (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é true —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ outDir –≤–Ω—É—Ç—Ä–∏ –ø—Ä–æ–µ–∫—Ç–∞)
    }
})


